/**
 * Utilities for visualizing benchmark results
 */
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { BenchmarkResult } from './benchmark-runner.js';

// Add fileURLToPath conversion for ESM compatibility 
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Convert benchmark results to an HTML report
 */
export function generateHtmlReport(results: BenchmarkResult[], title: string): string {
    const strategyColors: Record<string, string> = {
        'alphabetical': '#4285F4',
        'grouped': '#34A853',
        'concentric': '#FBBC05',
        'custom': '#EA4335'
    };

    const groupedBySize = groupResultsByInputSize(results);

    // Generate charts data
    const chartData = {
        labels: Object.keys(groupedBySize),
        datasets: generateDatasets(groupedBySize, strategyColors)
    };

    // Generate tables for each input size
    const tables = Object.entries(groupedBySize).map(([size, sizeResults]) => {
        return `
      <h3>Input Size: ${size} properties</h3>
      <table class="results-table">
        <thead>
          <tr>
            <th>Strategy</th>
            <th>Avg Time (ms)</th>
            <th>Median Time (ms)</th>
            <th>Min Time (ms)</th>
            <th>Max Time (ms)</th>
            <th>Ops/sec</th>
          </tr>
        </thead>
        <tbody>
          ${sizeResults.map(result => `
            <tr>
              <td>${result.strategy}</td>
              <td>${result.averageTimeMs.toFixed(4)}</td>
              <td>${result.medianTimeMs.toFixed(4)}</td>
              <td>${result.minTimeMs.toFixed(4)}</td>
              <td>${result.maxTimeMs.toFixed(4)}</td>
              <td>${result.operationsPerSecond.toFixed(2)}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
    }).join('');

    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${title}</title>
      <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
          line-height: 1.6;
          color: #333;
          max-width: 1200px;
          margin: 0 auto;
          padding: 20px;
        }
        h1, h2, h3 {
          margin-top: 30px;
        }
        .chart-container {
          margin: 40px 0;
          height: 400px;
        }
        .results-table {
          width: 100%;
          border-collapse: collapse;
          margin-bottom: 30px;
        }
        .results-table th, .results-table td {
          padding: 10px;
          border: 1px solid #ddd;
          text-align: left;
        }
        .results-table th {
          background-color: #f5f5f5;
        }
        .results-table tr:nth-child(even) {
          background-color: #f9f9f9;
        }
        footer {
          margin-top: 50px;
          color: #666;
          font-size: 14px;
          text-align: center;
        }
      </style>
    </head>
    <body>
      <h1>${title}</h1>
      <p>Generated on ${new Date().toLocaleString()}</p>
      
      <h2>Performance Comparison</h2>
      <div class="chart-container">
        <canvas id="performanceChart"></canvas>
      </div>
      
      <h2>Operations Per Second</h2>
      <div class="chart-container">
        <canvas id="opsChart"></canvas>
      </div>
      
      <h2>Detailed Results</h2>
      ${tables}
      
      <footer>
        Generated by Old Fashioned CSS Property Sorting Benchmarking Tool
      </footer>
      
      <script>
        // Performance chart
        const performanceCtx = document.getElementById('performanceChart').getContext('2d');
        new Chart(performanceCtx, {
          type: 'bar',
          data: ${JSON.stringify(chartData)},
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Average Time (ms)'
                }
              },
              x: {
                title: {
                  display: true,
                  text: 'Input Size (number of properties)'
                }
              }
            },
            plugins: {
              title: {
                display: true,
                text: 'Average Sorting Time by Strategy and Input Size'
              },
              legend: {
                position: 'top'
              }
            }
          }
        });
        
        // Operations per second chart
        const opsData = {
          labels: ${JSON.stringify(Object.keys(groupedBySize))},
          datasets: ${JSON.stringify(generateOpsDatasets(groupedBySize, strategyColors))}
        };
        
        const opsCtx = document.getElementById('opsChart').getContext('2d');
        new Chart(opsCtx, {
          type: 'line',
          data: opsData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Operations per Second'
                }
              },
              x: {
                title: {
                  display: true,
                  text: 'Input Size (number of properties)'
                }
              }
            },
            plugins: {
              title: {
                display: true,
                text: 'Operations per Second by Strategy and Input Size'
              },
              legend: {
                position: 'top'
              }
            }
          }
        });
      </script>
    </body>
    </html>
  `;
}

/**
 * Save HTML report to file
 */
export function saveHtmlReport(html: string, filename: string): void {
    const reportsDir = path.join(__dirname, '..', 'results', 'reports');

    // Create reports directory if it doesn't exist
    if (!fs.existsSync(reportsDir)) {
        fs.mkdirSync(reportsDir, { recursive: true });
    }

    const filePath = path.join(reportsDir, `${filename}.html`);
    fs.writeFileSync(filePath, html, 'utf-8');
    console.log(`HTML report saved to ${filePath}`);
}

/**
 * Helper function to group results by input size
 */
function groupResultsByInputSize(results: BenchmarkResult[]): Record<string, BenchmarkResult[]> {
    const grouped: Record<string, BenchmarkResult[]> = {};

    results.forEach(result => {
        // Use the name part after last dash as the size category
        const sizeName = result.name.includes('-') ?
            result.name.split('-').pop()! :
            result.inputSize.toString();

        if (!grouped[sizeName]) {
            grouped[sizeName] = [];
        }
        grouped[sizeName].push(result);
    });

    // Sort size categories in a logical order
    const sizeOrder = ['tiny', 'small', 'medium', 'large', 'extra-large', 'vendor-prefixes', 'custom-properties'];

    const sortedGrouped: Record<string, BenchmarkResult[]> = {};

    // First add known sizes in order
    sizeOrder.forEach(size => {
        if (grouped[size]) {
            sortedGrouped[size] = grouped[size];
        }
    });

    // Then add any other sizes that weren't in our predefined order
    Object.keys(grouped)
        .filter(size => !sizeOrder.includes(size))
        .forEach(size => {
            sortedGrouped[size] = grouped[size];
        });

    return sortedGrouped;
}

/**
 * Helper function to generate datasets for Chart.js
 */
function generateDatasets(groupedResults: Record<string, BenchmarkResult[]>, colors: Record<string, string>) {
    // Get unique strategies
    const strategies = new Set<string>();
    Object.values(groupedResults).forEach(results => {
        results.forEach(result => strategies.add(result.strategy));
    });

    return Array.from(strategies).map(strategy => {
        const data = Object.values(groupedResults).map(results => {
            const strategyResults = results.filter(r => r.strategy === strategy);
            if (strategyResults.length === 0) return null;
            return strategyResults.reduce((sum, r) => sum + r.averageTimeMs, 0) / strategyResults.length;
        });

        return {
            label: `${strategy} strategy`,
            data,
            backgroundColor: colors[strategy] || '#999999',
            borderColor: colors[strategy] || '#999999',
            borderWidth: 1
        };
    });
}

/**
 * Helper function to generate operation per second datasets
 */
function generateOpsDatasets(groupedResults: Record<string, BenchmarkResult[]>, colors: Record<string, string>) {
    // Get unique strategies
    const strategies = new Set<string>();
    Object.values(groupedResults).forEach(results => {
        results.forEach(result => strategies.add(result.strategy));
    });

    return Array.from(strategies).map(strategy => {
        const data = Object.values(groupedResults).map(results => {
            const strategyResults = results.filter(r => r.strategy === strategy);
            if (strategyResults.length === 0) return null;
            return strategyResults.reduce((sum, r) => sum + r.operationsPerSecond, 0) / strategyResults.length;
        });

        return {
            label: `${strategy} strategy`,
            data,
            backgroundColor: 'transparent',
            borderColor: colors[strategy] || '#999999',
            borderWidth: 2,
            tension: 0.1
        };
    });
}
